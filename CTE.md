# Capture the Ether

**Capture the Ether** serves as an introductory CTF (Capture the Flag) for those interested in smart contract security. It offers a variety of challenges categorized into different sections.

The first section is the Warmup consisting of basic things like deploying a contract and invoking functions. We will jump directly to the interesting part (starting from Section-2)

## 2. Lotteries:
### 2.1 Guess the number 

```solidity
pragma solidity ^0.4.21;

contract GuessTheNumberChallenge {
>>> uint8 answer = 42;

    function GuessTheNumberChallenge() public payable {
        require(msg.value == 1 ether);
    }

    function isComplete() public view returns (bool) {
        return address(this).balance == 0;
    }

    function guess(uint8 n) public payable {
        require(msg.value == 1 ether);

        if (n == answer) {
            msg.sender.transfer(2 ether);
        }
    }
}
```
The contract code reveals the number itself, and the answer to it is 42.

### 2.2 Guess the secret number

```solidity
pragma solidity ^0.4.21;

contract GuessTheSecretNumberChallenge {
    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;

    function GuessTheSecretNumberChallenge() public payable {
        require(msg.value == 1 ether);
    }
    
    function isComplete() public view returns (bool) {
        return address(this).balance == 0;
    }

    function guess(uint8 n) public payable {
        require(msg.value == 1 ether);

        if (keccak256(n) == answerHash) {
            msg.sender.transfer(2 ether);
        }
    }
}
```
- Since the answerHash is a value generated by hashing a number using `keccak256`, w.k.t encoded value can be decoded but a hash can not be de-hashed.
- To guess the number and receive the 2 ETH, we can try brute-forcing on the guess() [do it off-chain to avoid paying 1 ETH for every call] as it uses `uint8` which has the range of [0,255]

### 2.3 Guess the random number

```solidity
pragma solidity ^0.4.21;

contract GuessTheRandomNumberChallenge {
    uint8 answer;

    function GuessTheRandomNumberChallenge() public payable {
        require(msg.value == 1 ether);
        answer = uint8(keccak256(block.blockhash(block.number - 1), now));
    }

    function isComplete() public view returns (bool) {
        return address(this).balance == 0;
    }

    function guess(uint8 n) public payable {
        require(msg.value == 1 ether);

        if (n == answer) {
            msg.sender.transfer(2 ether);
        }
    }
}
```
There are two approaches: 
1. Since w.k.t the data stored in smart contracts is on-chain and is publicly available to be read by anyone (even if the variable is private). We can just read the `slot0` of the contract storage to get the `answer` value.
2. Using the same approach as the previous challenge for calculating the number using formula in the contract, because of `uint8` range being limited.

### 2.4 Guess the new number
The number is now generated on-demand when a guess is made.

```solidity
pragma solidity ^0.4.21;

contract GuessTheNewNumberChallenge {
    function GuessTheNewNumberChallenge() public payable {
        require(msg.value == 1 ether);
    }

    function isComplete() public view returns (bool) {
        return address(this).balance == 0;
    }

    function guess(uint8 n) public payable {
        require(msg.value == 1 ether);
        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));

        if (n == answer) {
            msg.sender.transfer(2 ether);
        }
    }
}
```
Since it calculates the `answer` only when the function is being called. We can not brute-force it off-chain and then call it again on-chain with calculated answer.
However, we can setup this contract locally, and use exact formula as above to calculate value of answer at the instance and using (foundry/hardhat) make a call on-chain within the same transaction.

> [!IMPORTANT]
> ðŸ“˜ This will work as we are performing all these actions in a single transaction
>  (`block.timestamp` formerly called `now`, `block.number` will be the same
> throughout the transaction execution)

>[!NOTE]
> When auditing smart contracts, think of the scenarios for blockchain variable dependent functions which can be called via front-running with a function like -  `guess(answer)` or calling within the same transaction to exploit them. 

### 2.5 Predict the future

```solidity
pragma solidity ^0.4.21;

contract PredictTheFutureChallenge {
    address guesser;
    uint8 guess;
    uint256 settlementBlockNumber;

    function PredictTheFutureChallenge() public payable {
        require(msg.value == 1 ether);
    }

    function isComplete() public view returns (bool) {
        return address(this).balance == 0;
    }

    function lockInGuess(uint8 n) public payable {
        require(guesser == 0);
        require(msg.value == 1 ether);

        guesser = msg.sender;
        guess = n;
        settlementBlockNumber = block.number + 1;
    }

    function settle() public {
        require(msg.sender == guesser);
        require(block.number > settlementBlockNumber);

        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;

        guesser = 0;
        if (guess == answer) {
            msg.sender.transfer(2 ether);
        }
    }
}
```
> [!NOTE]
> This challenge won't let us use the previous approach, as it requires to
> call`lockInGuess()` in a separate block than the block in which we call `settle()`.
First we need to call `lockNumber(n)` with any number we want between 0 and 9.

Then instead of wasting lots of ETH by calling settle() randomly we make an attacker contract to exploit this:  

Building the attack contract that have this function:
```solidity
     function settleChallenge() public payable {
        challenge.settle();  // calls settle that resets guesser (if wrong/right guess)
        require(challenge.isComplete(), "Wrong answer");  //checks if we got it right, if not we just revert this function, resetting the state changes made in the above function call `challenge.settle()`
        emit challengeSolved(address(this).balance);
    }
```
> [!IMPORTANT]
> One of the main properties of the Ethereum transactions is that they are _atomic_.
> It is all or nothing, they canâ€™t partially do what they are intended to do. We can sometimes exploit this to our advantange, scenarios where caller is bound to lose some value by calling fn like `settle()` if they have made wrong guess.
> Just reverting the whole function transaction can revert the loss of the caller/attacker and do brute-forcing to hack it even without losing any value.

### 2.6 Predict the block hash
```solidity
pragma solidity ^0.4.21;

contract PredictTheBlockHashChallenge {
    address guesser;
    bytes32 guess;
    uint256 settlementBlockNumber;

    function PredictTheBlockHashChallenge() public payable {
        require(msg.value == 1 ether);
    }

    function isComplete() public view returns (bool) {
        return address(this).balance == 0;
    }

    function lockInGuess(bytes32 hash) public payable {
        require(guesser == 0);
        require(msg.value == 1 ether);

        guesser = msg.sender;
        guess = hash;
        settlementBlockNumber = block.number + 1;
    }

    function settle() public {
        require(msg.sender == guesser);
        require(block.number > settlementBlockNumber);

        bytes32 answer = block.blockhash(settlementBlockNumber);

        guesser = 0;
        if (guess == answer) {
            msg.sender.transfer(2 ether);
        }
    }
}
```

This is an interesting value and a bit easy if you know about `blockhash(blocknumber)` global variable of blockchain. 

> [!NOTE]
> `blockhash(blocknumber)` returns the hash of the given block **only if the blocknumber is one of the most recent 256 blocks** else it returns 0.

To use this knowledge to our advantage we can do the following:
1. Call the lockInGuess(bytes32 hash) with `hash = 0`
2. Wait for 257 blocks (+1 block as settlementBlockNumber = block.number+1)  _Blocktime_ _(Block time is the amount of time it takes for validators/miners to verify transactions within a block and create a new block in a blockchain)._ Ethereum's average block time is 12.06 seconds.
   `256 * 12.06 = 3088 seconds (~52 mins)`
3. Call the `settle()` both require statements will return true and the guess value will also match as we are trying to get blockhash of block older than 256 blocks.

## 3. Math:
### Token Sale

```solidity
pragma solidity ^0.4.21;

contract TokenSaleChallenge {
    mapping(address => uint256) public balanceOf;
    uint256 constant PRICE_PER_TOKEN = 1 ether;

    function TokenSaleChallenge(address _player) public payable {
        require(msg.value == 1 ether);
    }

    function isComplete() public view returns (bool) {
        return address(this).balance < 1 ether;
    }

    function buy(uint256 numTokens) public payable {
        require(msg.value == numTokens * PRICE_PER_TOKEN);

        balanceOf[msg.sender] += numTokens;
    }

    function sell(uint256 numTokens) public {
        require(balanceOf[msg.sender] >= numTokens);

        balanceOf[msg.sender] -= numTokens;
        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);
    }
}
```
> [!NOTE]
> Solc versions >=0.8.0 doesn't have the overflow/underflow issue anymore.

In order to extract some ethers from this contract, which has 1 ETH already in it. As we can see that token has even rate to ETH (1e18 wei = 1 Token) we can leverage it to cause overflow.

1. As input an attacker can provide `numTokens` value, which is checked against `numTokens* 1 ether ~ numTokens * 1e18`, if we provide very large input, this check will cause overflow (starting from 0 again)
(numTokens * 1e18 - type(uint256).max) wei

2. For such input our msg.value will be low but the` balanceOf[msg.sender] = numTokens` will be huge and while calling `sell(numTokens)` we will be able to extract that extra ETH from the contract.
